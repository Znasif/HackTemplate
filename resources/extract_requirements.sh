#!/bin/bash

# Enhanced script to extract requirements from your conda environments
# This captures source-built dependencies, git installs, and custom builds
# Run this in your WSL2 environment where your conda envs are set up

set -e

echo "ğŸ” Enhanced requirements extraction for source-built dependencies..."

# Initialize conda properly
echo "ğŸ”§ Initializing conda..."

# Find conda installation
if [ -f "$HOME/miniconda3/etc/profile.d/conda.sh" ]; then
    CONDA_PATH="$HOME/miniconda3"
elif [ -f "$HOME/anaconda3/etc/profile.d/conda.sh" ]; then
    CONDA_PATH="$HOME/anaconda3"
elif [ -f "/opt/conda/etc/profile.d/conda.sh" ]; then
    CONDA_PATH="/opt/conda"
elif [ -f "/usr/local/miniconda3/etc/profile.d/conda.sh" ]; then
    CONDA_PATH="/usr/local/miniconda3"
else
    echo "âŒ Conda installation not found. Please ensure conda is installed and accessible."
    echo "Common locations checked:"
    echo "  - $HOME/miniconda3/etc/profile.d/conda.sh"
    echo "  - $HOME/anaconda3/etc/profile.d/conda.sh" 
    echo "  - /opt/conda/etc/profile.d/conda.sh"
    echo "  - /usr/local/miniconda3/etc/profile.d/conda.sh"
    exit 1
fi

echo "âœ… Found conda at: $CONDA_PATH"

# Source conda configuration
source "$CONDA_PATH/etc/profile.d/conda.sh"

# Verify conda is working
if ! command -v conda &> /dev/null; then
    echo "âŒ Conda command not available after sourcing. Please check your conda installation."
    exit 1
fi

echo "âœ… Conda initialized successfully"

# Create requirements directory
mkdir -p requirements

# Function to extract comprehensive environment info
extract_env_details() {
    local env_name=$1
    echo "ğŸ“¦ Analyzing environment: $env_name"
    
    # Check if environment exists
    if ! conda env list | grep -q "^$env_name "; then
        echo "âš ï¸  Environment '$env_name' not found. Skipping..."
        echo "Available environments:"
        conda env list
        return 1
    fi
    
    # Activate environment with proper conda initialization
    echo "  ğŸ”„ Activating environment: $env_name"
    if ! conda activate "$env_name"; then
        echo "âŒ Failed to activate environment: $env_name"
        return 1
    fi
    
    echo "  ğŸ“‹ Basic exports..."
    # Standard exports
    conda env export --name "$env_name" > "requirements/${env_name}.yml"
    
    # Generate cleaned pip requirements instead of raw pip freeze
    echo "  ğŸ§¹ Generating cleaned pip requirements..."
    
    # First get explicit conda package list for filtering
    conda list --explicit > "requirements/${env_name}-explicit.txt"
    local conda_packages=$(grep -o '[^/]*\.conda$\|[^/]*\.tar\.bz2$' "requirements/${env_name}-explicit.txt" | sed 's/-[0-9].*//' | sort | uniq)
    
    # Create cleaned pip requirements
    cat > "requirements/${env_name}-pip.txt" << EOF
# Cleaned pip requirements for $env_name environment
# Auto-generated by extract_requirements.sh
# Only includes PyPI packages not managed by conda, excluding file:// paths

EOF
    
    # Process pip freeze output with filtering
    pip freeze | while IFS= read -r line; do
        # Skip empty lines and comments
        if [[ -z "$line" || "$line" =~ ^# ]]; then
            continue
        fi
        
        # Skip lines with file:// (local conda build paths)
        if [[ "$line" =~ file:// ]]; then
            continue
        fi
        
        # Extract package name (everything before @ or ==)
        local package_name=""
        if [[ "$line" =~ ^([^@=\ ]+) ]]; then
            package_name="${BASH_REMATCH[1]}"
        else
            continue
        fi
        
        # Skip if package is managed by conda
        if echo "$conda_packages" | grep -q "^${package_name}$"; then
            continue
        fi
        
        # Skip packages that should prefer conda versions
        case "$package_name" in
            numpy|scipy|matplotlib|pillow|torch|torchvision|opencv-python|opencv-contrib-python|opencv-python-headless)
                continue
                ;;
        esac
        
        # Keep the package
        echo "$line" >> "requirements/${env_name}-pip.txt"
        
    done
    
    echo "  ğŸ” Detailed package analysis..."
    # Detailed conda package info (shows build strings and channels)
    conda list --json > "requirements/${env_name}-packages.json"
    
    echo "  ğŸŒ Git and editable packages..."
    # Find packages installed from git or in editable mode
    pip list --format=freeze | grep -E "(git\+|file://|@ file)" > "requirements/${env_name}-git-packages.txt" 2>/dev/null || echo "# No git packages found" > "requirements/${env_name}-git-packages.txt"
    
    # Find editable installs
    pip list --editable --format=freeze > "requirements/${env_name}-editable.txt" 2>/dev/null || echo "# No editable packages found" > "requirements/${env_name}-editable.txt"
    
    echo "  ğŸ—ï¸ Build and system info..."
    # System and build information
    cat > "requirements/${env_name}-system-info.txt" << EOF
# System Information for $env_name environment
# Generated on: $(date)
# Python version: $(python --version 2>/dev/null || echo "Python not available")
# Python executable: $(which python 2>/dev/null || echo "Python path not found")
# Conda version: $(conda --version 2>/dev/null || echo "Conda version not available")
# Platform: $(uname -a 2>/dev/null || echo "Platform info not available")

# CUDA Information (if available)
EOF
    
    # CUDA info
    if command -v nvidia-smi &> /dev/null; then
        echo "# NVIDIA Driver version:" >> "requirements/${env_name}-system-info.txt"
        nvidia-smi --query-gpu=driver_version --format=csv,noheader,nounits 2>/dev/null | head -1 >> "requirements/${env_name}-system-info.txt" || echo "# NVIDIA driver info not available" >> "requirements/${env_name}-system-info.txt"
    else
        echo "# NVIDIA drivers not available" >> "requirements/${env_name}-system-info.txt"
    fi
    
    # Python CUDA info if available
    echo "# Python CUDA availability:" >> "requirements/${env_name}-system-info.txt"
    python -c "
try:
    import torch
    print(f'PyTorch CUDA available: {torch.cuda.is_available()}')
    if torch.cuda.is_available():
        print(f'PyTorch CUDA version: {torch.version.cuda}')
        print(f'CUDA devices: {torch.cuda.device_count()}')
except ImportError:
    print('PyTorch not available')
except Exception as e:
    print(f'CUDA check error: {e}')
" >> "requirements/${env_name}-system-info.txt" 2>/dev/null || echo "# Python CUDA check failed" >> "requirements/${env_name}-system-info.txt"
    
    # Source-built package analysis
    echo "  ğŸ”¬ Analyzing source-built packages..."
    cat > "requirements/${env_name}-source-analysis.txt" << EOF
# Source-built package analysis for $env_name environment
# Generated on: $(date)
# Environment path: $CONDA_PREFIX
# Python path: $(which python)
-----------------------------------------------------------------

EOF
    
    # Check key packages that are often source-built
    local SOURCE_PACKAGES=("cv2" "torch" "torchvision" "numpy" "scipy" "pillow" "matplotlib" "open3d" "mediapipe")
    
    for pkg in "${SOURCE_PACKAGES[@]}"; do
        python -c "
import sys
try:
    import importlib.util
    spec = importlib.util.find_spec('$pkg')
    if spec and spec.origin:
        print(f'$pkg location: {spec.origin}')
        
        # Try to get build info
        try:
            mod = importlib.import_module('$pkg')
            if hasattr(mod, '__version__'):
                print(f'$pkg version: {mod.__version__}')
            if hasattr(mod, '__file__'):
                print(f'$pkg file: {mod.__file__}')
            if hasattr(mod, '__path__'):
                print(f'$pkg path: {mod.__path__}')
                
            # Special cases for build info
            if '$pkg' == 'cv2':
                try:
                    print(f'OpenCV build info: {mod.getBuildInformation()}')
                except:
                    print('OpenCV build info not available')
            elif '$pkg' == 'torch':
                try:
                    print(f'PyTorch compiled with CUDA: {mod.cuda.is_available()}')
                    if mod.cuda.is_available():
                        print(f'PyTorch CUDA arch list: {mod.cuda.get_arch_list()}')
                except:
                    print('PyTorch CUDA info not available')
        except Exception as e:
            print(f'$pkg import error: {e}')
except ImportError:
    pass
except Exception as e:
    print(f'Error checking $pkg: {e}')
" >> "requirements/${env_name}-source-analysis.txt" 2>/dev/null
    done
    
    # Check pip show for detailed package info including installation method
    echo "  ğŸ“– Detailed package metadata..."
    pip list --format=freeze | cut -d'=' -f1 | while read package; do
        if [ ! -z "$package" ] && [ "$package" != "#" ] && [[ ! "$package" =~ ^- ]]; then
            pip show "$package" 2>/dev/null | grep -E "(Name|Version|Location|Requires|Required-by)" >> "requirements/${env_name}-detailed-packages.txt" || true
            echo "---" >> "requirements/${env_name}-detailed-packages.txt"
        fi
    done 2>/dev/null || echo "# Detailed package info not available" > "requirements/${env_name}-detailed-packages.txt"
    
    echo "  âœ… Environment $env_name analysis complete"
    return 0
}

# List of environments to analyze
ENVIRONMENTS=("aws" "whatsai2" "depth-pro")

echo "ğŸ” Checking available conda environments..."
echo "Available environments:"
conda env list

echo ""
echo "ğŸ” Starting extraction for environments: ${ENVIRONMENTS[*]}"

# Extract from each environment
for env_name in "${ENVIRONMENTS[@]}"; do
    echo ""
    echo "ğŸ” Extracting $env_name environment..."
    if extract_env_details "$env_name"; then
        echo "âœ… Successfully extracted $env_name environment"
        
        # Show summary of cleaned pip requirements
        pip_count=$(grep -v '^#' "requirements/${env_name}-pip.txt" | grep -v '^$' | wc -l)
        echo "  ğŸ“Š Generated $pip_count cleaned pip packages"
        
        if [ $pip_count -gt 0 ]; then
            echo "  ğŸ” Key pip packages:"
            grep -v '^#' "requirements/${env_name}-pip.txt" | grep -v '^$' | head -5 | sed 's/^/    /'
            if [ $pip_count -gt 5 ]; then
                echo "    ... and $((pip_count - 5)) more"
            fi
        fi
    else
        echo "âš ï¸  Failed to extract $env_name environment"
    fi
done

echo "âœ… Requirements extracted to requirements/ directory"
echo "ğŸ“‹ Files generated for each environment:"
echo "  - {env}-explicit.txt     (exact conda package URLs)"
echo "  - {env}-pip.txt          (cleaned PyPI-only packages)"
echo "  - {env}.yml              (conda environment file)"
echo "  - {env}-packages.json    (detailed package metadata)"
echo "  - {env}-source-analysis.txt (source-built package info)"
echo ""
echo "ğŸ‰ Ready for Docker build with cleaned requirements!"